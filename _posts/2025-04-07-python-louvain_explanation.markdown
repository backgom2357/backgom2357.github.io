---
layout: post
title:  "python-louvain 패키지의 best_partition 함수를 이용한 네트워크 최적 분할 방법 상세 설명"
date:   2025-04-07
categories: programming
tags: algorithm
---

## 서론
네트워크 과학에서 네트워크 내의 촘촘하게 연결된 노드 그룹, 즉 커뮤니티를 식별하는 것은 중요한 과제입니다. 이러한 커뮤니티를 탐지하는 데 사용되는 효율적인 방법 중 하나가 루뱅 알고리즘이며, 특히 대규모 네트워크에서 그 유용성이 두드러집니다. python-louvain 패키지는 NetworkX 라이브러리의 기능을 활용하여 이 알고리즘을 파이썬으로 구현한 것으로, 네트워크 분석을 위한 강력한 도구를 제공합니다.

다양한 복잡계에서 모듈화된 구조가 흔히 발견된다는 점은 (생물학적 네트워크에서 기술적 그래프에 이르기까지) 루뱅 알고리즘과 같은 커뮤니티 탐지 알고리즘의 중요성을 강조합니다. 모듈성은 네트워크의 여러 부분이 어느 정도 분리될 수 있도록 하며, 생물학적 시스템의 진화 가능성을 위한 필수 조건으로 여겨지기도 합니다. 기술 분야에서는 모듈성이 명확한 작업 분할을 정의하며 명시적인 설계 목표가 됩니다.

또한, python-louvain 패키지가 NetworkX에 의존한다는 사실은 네트워크 분석을 위한 표준 파이썬 도구와의 강력한 통합을 의미하며, 이는 더 많은 사용자가 이 알고리즘을 네트워크 데이터에 쉽게 적용할 수 있도록 합니다.

## 모듈성(Modularity)
네트워크를 커뮤니티로 분할한 결과의 품질을 평가하는 척도로 모듈성(Modularity, Q)이라는 개념이 사용됩니다. 모듈성은 네트워크를 분할했을 때, 같은 커뮤니티 내의 노드들끼리 연결된 밀도가 다른 커뮤니티에 있는 노드들과 연결된 밀도보다 얼마나 더 높은지를 측정합니다. 일반적으로 -1에서 1 사이의 값을 가지며, 양수 값이 높을수록 네트워크의 커뮤니티 구조가 더 잘 형성되었다고 해석할 수 있습니다.

가중치가 있는 무방향 그래프에서 모듈성은 다음과 같은 수식으로 표현될 수 있습니다.

Q = (1/(2m)) * Σ<sub>i,j</sub> [A<sub>ij</sub> - (k<sub>i</sub>k<sub>j</sub>)/(2m)] δ(c<sub>i</sub>, c<sub>j</sub>)

여기서:
- A<sub>ij</sub>는 노드 i와 j 사이의 인접 행렬 값
- k<sub>i</sub>와 k<sub>j</sub>는 각각 노드 i와 j의 연결 정도(degree)
- m은 전체 엣지의 수
- δ(c<sub>i</sub>, c<sub>j</sub>)는 노드 i와 j가 같은 커뮤니티에 속하면 1, 그렇지 않으면 0을 나타냅니다.

모듈성은 동일한 네트워크에 대한 서로 다른 커뮤니티 분할 결과를 비교할 수 있는 수학적으로 엄밀한 방법을 제공합니다. 이 "품질" 측정 기준을 통해 루뱅 알고리즘은 식별된 커뮤니티 구조를 객관적으로 평가하고 반복적으로 개선할 수 있습니다.

또한, 동일한 연결 정도 분포를 갖는 랜덤 네트워크와의 비교는 모듈성의 핵심적인 측면입니다. 이는 탐지된 커뮤니티가 네트워크의 전반적인 구조의 단순한 결과가 아니라 통계적으로 유의미한 그룹임을 보장합니다. 이러한 무작위 모델 비교는 엣지 분포에 대한 기준 기대치를 제공합니다. 커뮤니티는 이러한 무작위 기대치보다 내부 연결 밀도가 높을 때 의미가 있다고 간주됩니다.

## 루뱅 알고리즘의 동작 원리

### 1. 노드 이동 단계
루뱅 알고리즘은 모듈성을 점진적으로 최적화하는 탐욕적 휴리스틱 방법으로, 두 단계의 과정을 반복합니다. 첫 번째 단계는 노드 이동 단계입니다.

1. 초기에는 네트워크의 각 노드가 자신만의 커뮤니티에 할당됩니다.
2. 그런 다음 알고리즘은 네트워크의 모든 노드를 무작위 순서로 반복적으로 순회합니다 (이러한 무작위성은 python-louvain의 random_state 매개변수를 통해 제어할 수 있습니다).
3. 각 노드 v에 대해 알고리즘은 v를 이웃 커뮤니티로 이동했을 때 모듈성의 변화를 고려합니다.
4. 각 잠재적 이동에 대해 모듈성 변화(ΔQ)가 계산됩니다. 

networkx 문서는 무방향 및 방향 그래프 모두에 대한 ΔQ의 특정 공식을 제공하지만, python-louvain 자체는 무방향 그래프만 지원합니다. 무방향 그래프에서 고립된 노드 i가 커뮤니티 C로 이동할 때의 모듈성 이득은 다음과 같습니다.

Δ Q = (k<sub>i,in</sub>/(2m)) - γ(Σ<sub>tot</sub> * k<sub>i</sub>)/(2m)<sup>2</sup>

여기서:
- k<sub>i,in</sub>은 i에서 C 내의 노드로 연결된 가중치의 합
- k<sub>i</sub>는 i에 연결된 모든 링크의 가중치 합
- Σ<sub>tot</sub>는 C 내의 노드에 연결된 모든 링크의 가중치 합
- m은 그래프의 전체 엣지 가중치입니다.
- 해상도 매개변수 γ (python-louvain의 resolution 매개변수를 통해 제어됨)는 커뮤니티 크기에 영향을 줄 수 있습니다.

5. 노드 v는 모듈성이 가장 크게 증가하는 이웃 커뮤니티로 이동합니다. 어떤 이동으로도 양의 증가가 없으면 노드는 현재 커뮤니티에 남아 있습니다.
6. 모든 노드를 순회하고 모듈성 개선에 따라 커뮤니티를 업데이트하는 이 과정은 전체 패스에서 더 이상 네트워크의 모듈성을 개선할 수 없을 때까지 계속됩니다. 이는 이 단계에서 지역 최적점에 도달했음을 의미합니다.

노드 이동 단계의 반복적이고 탐욕적인 특성은 최종 커뮤니티 할당이 노드가 고려되는 순서에 따라 달라질 수 있음을 의미합니다. python-louvain의 randomize 및 random_state 매개변수를 통해 이 측면을 제어할 수 있습니다. 순서를 무작위화함으로써 알고리즘은 모듈성 지형에서 다른 지역 최적점을 탐색할 수 있습니다. 다른 무작위 시드로 알고리즘을 여러 번 실행하면 약간 다르지만 똑같이 좋은 분할을 얻을 수 있습니다.

또한, 모듈성 이득 공식(ΔQ)은 엣지의 가중치를 명시적으로 고려하여 알고리즘이 가중치 네트워크에서도 작동할 수 있도록 합니다 (python-louvain에서 weight 매개변수를 지정한 경우). 이러한 기능은 연결 강도 또는 중요도가 다양한 실제 네트워크를 분석하는 데 매우 중요합니다.

### 2. 커뮤니티 병합 단계
첫 번째 단계가 완료되면 알고리즘은 두 번째 단계인 커뮤니티 병합 단계를 수행하여 새로운 축소된 네트워크를 구성합니다. 이 새로운 네트워크에서 각 노드는 첫 번째 단계에서 식별된 커뮤니티를 나타냅니다. 이러한 새로운 "커뮤니티 노드" 간의 엣지는 원래 네트워크에서 해당 커뮤니티 간의 연결을 나타냅니다.

두 커뮤니티 노드 간의 엣지 가중치는 원래 그래프에서 해당 두 커뮤니티에 속하는 노드들을 연결하는 모든 엣지 가중치의 합입니다. 이러한 병합 단계를 통해 알고리즘은 계층적 커뮤니티 구조를 탐지할 수 있습니다. 커뮤니티를 단일 노드로 취급함으로써 알고리즘은 이러한 커뮤니티의 더 높은 수준의 그룹화를 찾을 수 있습니다.

### 알고리즘 종료 조건
그런 다음 알고리즘은 이 새로운 더 작은 커뮤니티 네트워크에 대해 첫 번째 단계(노드 이동)를 반복합니다. 이러한 두 단계(노드 이동 및 커뮤니티 병합)는 다음 조건 중 하나가 충족될 때까지 반복적으로 수행됩니다:

1. 네트워크 분할의 모듈성이 반복 간에 더 이상 증가하지 않음
2. 미리 정의된 최대 수준 수(max_level 매개변수)에 도달함
3. 모듈성 변화가 지정된 임계값(threshold 매개변수) 아래로 떨어짐

이러한 종료 조건은 안정적인 상태(지역 모듈성 최대값)에 도달하거나 (threshold 때문) 또는 계산 자원이 소진되었을 때(max_level 때문) 알고리즘이 중지되도록 보장합니다. 이러한 매개변수는 커뮤니티 탐지 프로세스의 런타임과 세분성을 제어하는 방법을 제공합니다.

## Python-Louvain 패키지의 Best_Partition 함수

python-louvain 패키지의 community 모듈에 있는 `best_partition(graph, partition=None, weight='weight', resolution=1., randomize=None, random_state=None)` 함수는 위에서 설명한 루뱅 알고리즘을 구현합니다.

### 매개변수 설명
- **graph**: 필수 입력 매개변수로 NetworkX 그래프 객체를 입력으로 받습니다. 그래프는 무방향이어야 합니다.
- **partition**: 선택적 매개변수로 미리 정의된 초기 분할로 알고리즘을 시작할 수 있습니다.
- **weight**: 가중치에 사용할 엣지 속성을 지정합니다 (기본값은 'weight'). None이면 그래프는 가중치가 없는 것으로 처리됩니다.
- **resolution**: 기본값은 1.0으로, 탐지된 커뮤니티의 크기에 영향을 미칩니다. 1.0보다 작은 값은 더 큰 커뮤니티를 선호하고, 1.0보다 큰 값은 더 작은 커뮤니티를 선호합니다.
- **randomize**: 부울 값으로, 기본값은 None입니다. True이면 각 패스에서 노드 및 커뮤니티 평가 순서를 무작위화합니다.
- **random_state**: 정수(시드), RandomState 인스턴스 또는 None일 수 있으며, 재현성을 위해 무작위성을 제어합니다.

### 반환 값
함수는 키가 그래프의 노드이고 값이 각 노드가 속한 커뮤니티인 (0부터 커뮤니티 수까지 번호가 매겨진) 딕셔너리를 반환합니다.

python-louvain의 best_partition 함수는 기본 루뱅 알고리즘에서 생성된 커뮤니티 계층 구조의 덴드로그램에서 가장 높은 모듈성을 갖는 분할을 찾는 것에 직접적으로 해당합니다. 알고리즘은 암묵적으로 분할 계층 구조를 구축하고, best_partition은 모든 수준에서 최대 모듈성 점수를 달성하는 분할을 반환합니다.

또한, python-louvain 패키지는 전체 커뮤니티 계층 구조를 탐색하는 `generate_dendrogram` 및 특정 수준에서 분할을 추출하는 `partition_at_level`과 같은 다른 유용한 함수도 제공합니다. 이러한 함수는 단일 "최적" 분할을 넘어 커뮤니티 구조에 대한 더 세밀한 제어 및 통찰력을 제공합니다.

### 최적 분할 결정 방식
best_partition 함수는 기본적으로 그래프 분할의 모듈성이 지역 최대값에 도달하고 계층 구조의 어떤 수준에서도 모든 노드를 완전히 통과하는 동안 더 이상 개선이 없을 때까지 노드 이동 및 커뮤니티 병합의 반복적 프로세스를 계속합니다.

알고리즘은 덴드로그램의 각 수준에서 모듈성 점수를 암묵적으로 추적합니다. 함수에서 반환하는 "최적" 분할은 이 프로세스 중에 발견된 가장 높은 모듈성 값에 해당하는 분할입니다.

또한, 알고리즘은 다음과 같은 경우에 중지될 수 있습니다:
- 두 수준 간의 모듈성 변화가 threshold 매개변수 아래로 떨어질 때
- 사용자가 지정한 max_level에 도달했을 때(이 경우 모듈성이 완전히 수렴되지 않았더라도 알고리즘이 중지됨)

여기서 "최적"이라는 개념은 알고리즘 실행 중에 발견된 가장 높은 모듈성 점수를 산출하는 분할을 의미합니다. 모듈성은 좋은 휴리스틱이지만, 알고리즘이 탐욕적이므로 절대적으로 가장 높은 가능한 모듈성을 갖는 전역적으로 최적인 분할을 찾지 못할 수도 있다는 점을 기억하는 것이 중요합니다.

threshold 매개변수는 더 높은 모듈성 검색과 계산 효율성 간의 균형을 맞추는 실용적인 방법을 제공합니다. 더 작은 임계값은 약간 더 나은 분할로 이어질 수 있지만 런타임을 늘릴 수도 있습니다.

## 알고리즘의 한계점

루뱅 알고리즘은 탐욕적 휴리스틱이므로 각 단계에서 지역적으로 최적의 결정을 내립니다. 이로 인해 효율적이지만 절대적으로 가장 높은 모듈성을 갖는 전역적으로 최적인 분할을 찾는 것을 보장하지는 않습니다. 알고리즘은 지역 최적점에 갇힐 수 있습니다.

루뱅을 포함한 모듈성 최적화 방법은 "해상도 제한"이라는 문제가 있습니다. 즉, 전체 네트워크에 훨씬 더 큰 커뮤니티가 포함되어 있는 경우 작고 밀접하게 연결된 커뮤니티를 탐지하지 못할 수 있습니다. resolution 매개변수는 이를 어느 정도 완화하는 데 도움이 될 수 있습니다.

python-louvain에 구현된 표준 루뱅 알고리즘은 비중첩 커뮤니티를 생성하므로 각 노드는 정확히 하나의 커뮤니티에 속합니다. 이는 노드가 여러 소속을 가질 수 있는 모든 유형의 네트워크에 현실적이지 않을 수 있습니다.

알고리즘의 탐욕적인 특성으로 인해 첫 번째 단계에서 노드를 방문하는 순서가 최종 결과에 영향을 줄 수 있습니다. randomize 및 random_state 매개변수를 사용하여 이러한 변동성을 탐색할 수 있습니다.

알고리즘은 때때로 "브리지" 노드가 이동하면 내부적으로 연결이 끊어진 커뮤니티를 생성할 수 있습니다.

검토된 자료에 따르면 python-louvain의 best_partition 함수는 무방향 그래프에서만 작동합니다. 방향 그래프의 경우 다른 구현 또는 알고리즘이 필요합니다.

입력 그래프의 자체 루프는 이전에 축소된 커뮤니티로 처리되므로 자체 루프의 특성에 따라 특별한 처리가 필요할 수 있습니다.

효율성과 전역 최적 해 보장 사이의 절충은 탐욕적 휴리스틱의 일반적인 특징인 루뱅 알고리즘의 근본적인 특징입니다. 절대적으로 최상의 분할에 대한 이론적 보장을 제공하지는 않지만, 루뱅 알고리즘은 특히 대규모 네트워크에서 합리적인 계산 비용으로 실제로 매우 좋은 분할을 찾는 경우가 많습니다.

해상도 제한은 모듈성 기반 방법의 고유한 제약 조건입니다. 특히 다양한 크기의 커뮤니티를 포함할 수 있는 네트워크를 다룰 때 루뱅 알고리즘의 결과를 해석하려면 이러한 제한 사항을 이해하는 것이 중요합니다.

## 결론

python-louvain 패키지의 best_partition 함수는 무방향 네트워크에서 커뮤니티 구조를 탐지하기 위해 탐욕적 휴리스틱 방법인 루뱅 알고리즘을 사용합니다. 이 알고리즘은 모듈성을 국부적으로 개선하기 위한 노드 이동과 계층적 구조를 구축하기 위한 커뮤니티 병합이라는 두 단계를 통해 네트워크의 모듈성을 반복적으로 최적화합니다.

이 프로세스는 모듈성의 지역 최대값에 도달하거나 다른 중지 기준 (임계값, 최대 수준)이 충족될 때까지 계속됩니다. 함수에서 반환하는 "최적" 분할은 탐색된 커뮤니티 계층 구조의 여러 수준에서 가장 높은 모듈성 점수를 달성한 분할입니다.

사용자는 알고리즘의 탐욕적인 특성, 지역 최적점의 가능성, 해상도 제한 및 python-louvain 구현에서의 무방향 그래프 제한을 포함한 알고리즘의 특징을 인식해야 합니다.

## 매개변수 요약표

| 매개변수 | 유형 | 기본값 | 설명 |
|----------|------|--------|------|
| graph | NetworkX Graph | 필수 | 입력 무방향 NetworkX 그래프입니다. |
| partition | dict, optional | None | 노드의 초기 분할입니다. |
| weight | str, optional | 'weight' | 가중치에 사용할 엣지 속성입니다. |
| resolution | float, optional | 1.0 | 커뮤니티 크기를 제어합니다 (1보다 작으면 더 크게, 1보다 크면 더 작게 선호). |
| randomize | boolean, optional | None | True이면 각 패스에서 노드 및 커뮤니티 평가 순서를 무작위화합니다. |
| random_state | int, RandomState, None | None | 재현성을 위한 난수 생성기의 시드입니다. |